#' Query the Allen Brain Atlas API for experiment IDs based on gene symbol.
#'
#' @param gene_symbol A character vector containing a gene symbol.
#' @param plane The plane of the ISH experiment to search for. Options are "coronal" and "saggital". Default is "coronal".
#'
#' @return a character vector of valid experiment IDs
#' @export
#'
#' @examples
#' ids <- aba_find_gene_ids("Pvalb", "coronal"
#' )
aba_find_gene_ids <- function(gene_symbol,
                             plane = "coronal") {
  query <- paste0(
    "http://api.brain-map.org/api/v2/data/query.xml?criteria=
     model::SectionDataSet,
     rma::criteria,[failed$eq'false'],
     products[abbreviation$eq'Mouse'],
     plane_of_section[name$eq'", plane, "'],
     genes[acronym$eq'", gene_symbol, "']"
  )
  query <- gsub("[ \n]+", "", query)

  id_url <- xml2::read_xml(query)
  id_nodes <- xml2::xml_find_all(id_url, xpath = "//Response/section-data-sets/section-data-set/id")
  ids <- as.character(xml_contents(id_nodes))

  ids
}

#' Query the Allen Brain Atlas API to retrieve an ISH energy array for an experiment ID
#'
#' @param id ISH experiment id, like that generated by aba_find_gene_ids()
#'
#' @return A 3-dimensional array of energy values with dims = c(67, 41, 58).
#'
#' @export
#'
#' @examples
#' library(dplyr)
#'
#' pvalb_arr <- aba_find_gene_ids("Pvalb") %>%
#'   aba_get_energy_array()
#'
aba_get_energy_array <- function(id) {
  if(length(id) > 1) {
    warning("Length of id > 1. Will use the first id value")
    id <- id[1]
  }

  array_dims <- c(67, 41, 58)

  query <- paste0(
    "http://api.brain-map.org/grid_data/download/",
    id,
    "?include=energy"
  )
  query <- gsub("[ \n]+", "", query)

  temp <- tempfile(fileext = ".zip")

  download.file(query, temp, mode = "wb")

  raw_file <- unz(temp, "energy.raw", "rb")
  vol_raw <- readBin(raw_file, "double", size = 4, n = prod(array_dims))
  close(raw_file)

  file.remove(temp)

  array(vol_raw, dim = array_dims)
}

#' Slice an Allen Brain Atlas ISH Array to return a matrix from a single plane.
#'
#' @param arr The 3-dimensional ISH array to slice
#' @param slice A numeric value for the slice to use.
#' @param plane Which plane to return. Options are "coronal", "saggital", and "horizontal". Default is "coronal"
#'
#' @return A 2-dimensional array of ISH values
#' @export
#'
#' @examples
#' library(dplyr)
#'
#' pvalb_mat <- aba_find_gene_ids("Pvalb") %>%
#'   aba_get_energy_array() %>%
#'   aba_slice_array(42, "coronal")
#'
aba_slice_array <- function(arr,
                            slice,
                            plane = "coronal") {

  if(plane == "coronal") {
    arr[slice, , ]
  } else if(plane == "saggital") {
    arr[, slice, ]
  } else if(plane == "horizontal") {
    arr[, , slice]
  }

}

#' Retrieve the Allen Brain Atlas Annotation ID array for Gridded expression data.
#'
#' @return a 3-dimensional array with dims = c(67, 41, 58)
#' @export
#'
#' @examples
#' anno_arr <- aba_get_annotation_array()
#'
aba_get_annotation_array <- function() {
  array_dims <- c(67, 41, 58)

  temp <- tempfile()

  query <- "http://download.alleninstitute.org/informatics-archive/current-release/mouse_annotation/P56_Mouse_gridAnnotation.zip"
  download.file(query, temp)

  raw_file <- unz(temp, "gridAnnotation.raw", "rb")
  vol_raw <- readBin(raw_file, "integer", size = 4, n = prod(array_dims))
  close(raw_file)

  file.remove(temp)

  array(vol_raw, dim = array_dims)
}

aba_slice_anno_boundaries <- function(anno,
                                      slice_num,
                                      direction = "coronal") {
  slice_anno <- filter_anno_slice(anno, slice_num, direction) %>%
    rename(atlas_x = x,
           atlas_y = y)

  slice_anno <- slice_anno %>%
    mutate(atlas_id = ifelse(atlas_x < 30, paste0(atlas_id, "_r"), paste0(atlas_id, "_l")))

  min_x_lines <- slice_anno %>%
    arrange(atlas_x, atlas_y) %>%
    mutate(border = lag(acronym) != acronym | lag(atlas_y, default = -100) != atlas_y - 1) %>%
    filter(border) %>%
    mutate(y = atlas_y - 0.5,
           yend = atlas_y - 0.5) %>%
    mutate(x = atlas_x - 0.5,
           xend = atlas_x + 0.5) %>%
    select(x, xend, y, yend) %>%
    unique()

  max_x_lines <- slice_anno %>%
    arrange(atlas_x, atlas_y) %>%
    mutate(border = lead(acronym) != acronym | lead(atlas_y, default = -100) != atlas_y + 1) %>%
    filter(border) %>%
    mutate(y = atlas_y + 0.5,
           yend = atlas_y + 0.5) %>%
    mutate(x = atlas_x - 0.5,
           xend = atlas_x + 0.5) %>%
    select(x, xend, y, yend) %>%
    unique()


  min_y_lines <- slice_anno %>%
    arrange(atlas_y, atlas_x) %>%
    mutate(border = lag(acronym) != acronym | lag(atlas_x, default = -100) != atlas_x - 1) %>%
    filter(border) %>%
    mutate(x = atlas_x - 0.5,
           xend = atlas_x - 0.5) %>%
    mutate(y = atlas_y - 0.5,
           yend = atlas_y + 0.5) %>%
    select(x, xend, y, yend) %>%
    unique()

  max_y_lines <- slice_anno %>%
    arrange(atlas_y, atlas_x) %>%
    mutate(border = lead(acronym) != acronym | lead(atlas_x, default = -100) != atlas_x + 1) %>%
    filter(border) %>%
    mutate(x = atlas_x + 0.5,
           xend = atlas_x + 0.5) %>%
    mutate(y = atlas_y - 0.5,
           yend = atlas_y + 0.5) %>%
    select(x, xend, y, yend) %>%
    unique()

  all_lines <- rbind(min_x_lines,
                     max_x_lines,
                     min_y_lines,
                     max_y_lines)

}

#' Get the Allen Brain Atlas structure graph ontology from the Allen API
#'
#' @return a nested list containing the allen brain atlas ontology.
#' @export
#'
#' @examples
#' ont <- aba_get_ontology()
#'
aba_get_ontology <- function() {

  # Download the ontology JSON file
  temp <- tempfile()
  download.file("http://api.brain-map.org/api/v2/structure_graph_download/1.json", temp)

  # Read the JSON
  raw_ontology <- jsonlite::fromJSON(temp)[["msg"]]

  return(raw_ontology)
}

#' Convert the nested Allen Brain Atlas ontology to a data.frame.
#'
#' @param @ontology The list-based ontology returned by the aba_get_ontology() function.
#' @param ontology_df The current ABA ontology data.frame. Used for recursive unpacking of the list ontology.
#'
#' @return a data.frame containing the ontology, along with a parent_id column for retaining hierarchical information.
#' @export
#'
#' @examples
#' library(dplyr)
#'
#' ont_df <- aba_get_ontology() %>%
#'   aba_flatten_ontology()
#'
aba_flatten_ontology <- function(ontology, ontology_df = NULL) {

  l <- ontology

  if(is.null(ontology_df)) {
    ontology_df <- data.frame(l[names(l) != "children"])[0,]
    ontology_df$n_children <- numeric()
  }

  if("children" %in% names(l)) {

    child_df <- data.frame(l[names(l) != "children"])

    n_children_of_children <- map_dbl(l$children,
                                      function(x) {
                                        if("children" %in% names(x)) {
                                          length(x$children)
                                        } else {
                                          0
                                        }
                                      })

    child_df$n_children <- n_children_of_children

    ontology_df <- rbind(ontology_df, child_df)

    for(i in 1:length(l$children)) {

      child_list <- l$children[[i]]

      ontology_df <- aba_flatten_ontology(child_list, ontology_df)
    }
  }

  return(ontology_df)
}

#' Convert an Allen Brain Atlas 3-d array to a data.frame
#'
#'
aba_melt <- function(arr, val = "value") {
  df <- reshape2::melt(arr)
  names(df) <- c("x","y","z",val)
  df
}
